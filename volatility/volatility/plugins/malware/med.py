import os
import json
import volatility.utils as utils
import volatility.debug as debug
import volatility.plugins.vadinfo as vadinfo
from volatility.plugins.malware import malfind
from volatility.plugins.malware.gargoyle import gargoyle
from volatility.plugins.procdump import ProcDump


# --------------------------------------------------------------------------------
# MED
# --------------------------------------------------------------------------------

class MED(vadinfo.VADDump):
    """Find detection evasion injections"""

    def __init__(self, config, *args, **kwargs):
        vadinfo.VADDump.__init__(self, config, *args, **kwargs)
        config.remove_option("BASE")
        config.add_option('SCANNERS', short_option='s', default=None,
                          help='Run these detection scanners (comma-separated)',
                          action='store', type='str')

    def render_text(self, outfd, data):
        if self._config.DUMP_DIR and not os.path.isdir(self._config.DUMP_DIR):
            debug.error(self._config.DUMP_DIR + " is not a directory")

        for result in gargoyle(self._config).calculate():
            for task in data:
                if task.UniqueProcessId != result.process.UniqueProcessId:
                    continue

                for vad, address_space in task.get_vads():
                    if (result.probablePayload < vad.Start or
                            result.probablePayload > vad.End):
                        continue

                    content = address_space.zread(result.probablePayload, 64)

                    outfd.write("Process: {0} Pid: {1} Address: {2:#x}\n".format(
                        result.process.ImageFileName, result.process.UniqueProcessId, vad.Start))

                    outfd.write("Vad Tag: {0} Protection: {1}\n".format(
                        vad.Tag, vadinfo.PROTECT_FLAGS.get(vad.VadFlags.Protection.v(), "")))

                    outfd.write("Flags: {0}\n".format(str(vad.VadFlags)))
                    outfd.write("\n")

                    # this is for address reporting in the output 
                    data_start = vad.Start

                    outfd.write("{0}\n".format("\n".join(
                        ["{0:#018x}  {1:<48}  {2}".format(data_start + o, h, ''.join(c))
                         for o, h, c in utils.Hexdump(content)
                         ])))

                    outfd.write("\n")
                    outfd.write("\n".join(
                        ["{0:#018x} {1:<16} {2}".format(o, h, i)
                         for o, i, h in malfind.Disassemble(content, data_start)
                         ]))

                    # Dump the data if --dump-dir was supplied
                    if self._config.DUMP_DIR:
                        filename = os.path.join(self._config.DUMP_DIR,
                                                "process.{0}.{1:#x}.dmp".format(
                                                    result.process.UniqueProcessId, vad.Start))

                        self.dump_vad(filename, vad, address_space)
                        proc_dump = ProcDump(self._config)
                        task_space = task.get_process_address_space()
                        dump_file = "executable.{0}.exe".format(task.UniqueProcessId)
                        proc_dump.dump_pe(task_space, task.Peb.ImageBaseAddress, dump_file)
                    outfd.write("\n\n")

    def render_json(self, outfd, data):
        results = []
        if self._config.DUMP_DIR and not os.path.isdir(self._config.DUMP_DIR):
            debug.error(self._config.DUMP_DIR + " is not a directory")

        for result in gargoyle(self._config).calculate():
            for task in data:
                if task.UniqueProcessId != result.process.UniqueProcessId:
                    continue

                for vad, address_space in task.get_vads():
                    if (result.probablePayload < vad.Start or
                            result.probablePayload > vad.End):
                        continue

                    content = address_space.zread(result.probablePayload, 64)

                    process_info = {
                        "Process": str(result.process.ImageFileName),
                        "Pid": int(result.process.UniqueProcessId),
                        "Address": hex(vad.Start),
                        "Vad Tag": str(vad.Tag),
                        "Protection": vadinfo.PROTECT_FLAGS.get(vad.VadFlags.Protection.v(), ""),
                        "Flags": str(vad.VadFlags),
                        "Hexdump": [],
                        "Disassembly": []
                    }

                    data_start = vad.Start

                    # Hexdump content
                    process_info["Hexdump"] = [
                        {
                            "address": hex(data_start + o),
                            "hex": h,
                            "char": ''.join(c)
                        }
                        for o, h, c in utils.Hexdump(content)
                    ]

                    # Disassemble content
                    process_info["Disassembly"] = [
                        {
                            "address": hex(o),
                            "instruction": i,
                            "hex": h
                        }
                        for o, i, h in malfind.Disassemble(content, data_start)
                    ]

                    # Dump the data if --dump-dir was supplied
                    if self._config.DUMP_DIR:
                        filename = os.path.join(self._config.DUMP_DIR,
                                                "process.{0}.{1:#x}.dmp".format(
                                                    result.process.UniqueProcessId, vad.Start))

                        self.dump_vad(filename, vad, address_space)
                        proc_dump = ProcDump(self._config)
                        task_space = task.get_process_address_space()
                        dump_file = "executable.{0}.exe".format(task.UniqueProcessId)
                        proc_dump.dump_pe(task_space, task.Peb.ImageBaseAddress, dump_file)

                    results.append(process_info)

        json.dump(results, outfd, indent=4)
