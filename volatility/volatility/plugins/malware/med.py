import logging
import os
import json
import volatility.utils as utils
import volatility.debug as debug
import volatility.plugins.vadinfo as vadinfo
from volatility.plugins.malware import malfind
from volatility.plugins.malware.gargoyle import gargoyle
from volatility.plugins.procdump import ProcDump


# --------------------------------------------------------------------------------
# MED
# --------------------------------------------------------------------------------

class MED(vadinfo.VADDump):
    """Find detection evasion injections"""

    def __init__(self, config, *args, **kwargs):
        vadinfo.VADDump.__init__(self, config, *args, **kwargs)
        self.logger = logging.getLogger('MEDLogger')
        self.logger.setLevel(logging.DEBUG)
        self.logger.addHandler(logging.NullHandler())
        self.logger.propagate = False
        config.remove_option("BASE")
        config.add_option('SCANNERS', short_option='s', default=None,
                          help='Run these detection scanners (comma-separated)',
                          action='store', type='str')
        config.add_option('LOG_FILE_PATH', short_option='Q', default=None,
                          help='Path to the log file',
                          action='store', type='str')

        if config.LOG_FILE_PATH:
            self.config_logger(config.LOG_FILE_PATH)

    def config_logger(self, log_file_path):
        # Remove existing handlers
        for handler in self.logger.handlers[:]:
            self.logger.removeHandler(handler)

        file_handler = logging.FileHandler(log_file_path)
        file_handler.setLevel(logging.DEBUG)

        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                                      datefmt='%Y-%m-%d %H:%M:%S')
        file_handler.setFormatter(formatter)

        self.logger.addHandler(file_handler)

    def render_text(self, outfd, data):
        if self._config.DUMP_DIR and not os.path.isdir(self._config.DUMP_DIR):
            debug.error(self._config.DUMP_DIR + " is not a directory")

        self.logger.info("Rendering text output")

        process_list = list(data)
        for result in gargoyle(self._config).calculate():
            for task in process_list:
                if task.UniqueProcessId != result.process.UniqueProcessId:
                    continue

                for vad, address_space in task.get_vads():
                    if (result.probablePayload < vad.Start or
                            result.probablePayload > vad.End):
                        continue

                    content = address_space.zread(result.probablePayload, 64)

                    outfd.write("Process: %s Pid: %d Address: %#x\n" % (
                        result.process.ImageFileName, result.process.UniqueProcessId, vad.Start))

                    outfd.write("Vad Tag: %s Protection: %s\n" % (
                        vad.Tag, vadinfo.PROTECT_FLAGS.get(vad.VadFlags.Protection.v(), "")))

                    outfd.write("Flags: %s\n" % str(vad.VadFlags))
                    outfd.write("\n")

                    data_start = vad.Start

                    outfd.write("%s\n" % "\n".join(
                        ["%#018x  %-48s  %s" % (data_start + o, h, ''.join(c))
                         for o, h, c in utils.Hexdump(content)
                         ]))

                    outfd.write("\n")
                    outfd.write("\n".join(
                        ["%#018x %-16s %s" % (o, h, i)
                         for o, i, h in malfind.Disassemble(content, data_start)
                         ]))

                    if self._config.DUMP_DIR:
                        filename = os.path.join(self._config.DUMP_DIR,
                                                "process.%d.%#x.dmp" % (
                                                    result.process.UniqueProcessId, vad.Start))

                        self.dump_vad(filename, vad, address_space)
                        proc_dump = ProcDump(self._config)
                        task_space = task.get_process_address_space()
                        dump_file = "executable.%d.exe" % task.UniqueProcessId
                        proc_dump.dump_pe(task_space, task.Peb.ImageBaseAddress, dump_file)
                    outfd.write("\n\n")

                    self.logger.info("Rendered text for process %s with PID %d" % (
                        result.process.ImageFileName, result.process.UniqueProcessId))

    def render_json(self, outfd, data):
        results = []
        if self._config.DUMP_DIR and not os.path.isdir(self._config.DUMP_DIR):
            debug.error(self._config.DUMP_DIR + " is not a directory")

        self.logger.info("Rendering JSON output")

        process_list = list(data)
        for result in gargoyle(self._config).calculate():
            for task in process_list:
                if task.UniqueProcessId != result.process.UniqueProcessId:
                    continue

                for vad, address_space in task.get_vads():
                    if (result.probablePayload < vad.Start or
                            result.probablePayload > vad.End):
                        continue

                    content = address_space.zread(result.probablePayload, 64)

                    process_info = {
                        "Process": str(result.process.ImageFileName),
                        "Pid": int(result.process.UniqueProcessId),
                        "Address": hex(vad.Start),
                        "Vad Tag": str(vad.Tag),
                        "Protection": vadinfo.PROTECT_FLAGS.get(vad.VadFlags.Protection.v(), ""),
                        "Flags": str(vad.VadFlags),
                        "Hexdump": [],
                        "Disassembly": []
                    }

                    data_start = vad.Start

                    process_info["Hexdump"] = [
                        {
                            "address": hex(data_start + o),
                            "hex": h,
                            "char": ''.join(c)
                        }
                        for o, h, c in utils.Hexdump(content)
                    ]

                    process_info["Disassembly"] = [
                        {
                            "address": hex(o),
                            "instruction": i,
                            "hex": h
                        }
                        for o, i, h in malfind.Disassemble(content, data_start)
                    ]

                    if self._config.DUMP_DIR:
                        filename = os.path.join(self._config.DUMP_DIR,
                                                "process.%d.%#x.dmp.dnr" % (
                                                    result.process.UniqueProcessId, vad.Start))

                        self.dump_vad(filename, vad, address_space)
                        proc_dump = ProcDump(self._config)
                        task_space = task.get_process_address_space()
                        dump_file = "executable.%d.exe.dnr" % task.UniqueProcessId
                        proc_dump.dump_pe(task_space, task.Peb.ImageBaseAddress, dump_file)

                    results.append(process_info)

                    self.logger.info("Rendered JSON for process %s with PID %d" % (
                        result.process.ImageFileName, result.process.UniqueProcessId))

        json.dump(results, outfd, indent=4)
